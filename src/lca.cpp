#include <bits/stdc++.h>

using namespace std;

// lca stabil
// pre process O(N log N)
// query O(log N) per query
class LCA {
	private:
		const static int MAXN = 100100;
		const static int LOGMAXN = 20;
		int N;
		int T[MAXN], P[MAXN][LOGMAXN], L[MAXN];
		// N = jumlah node
		// T = parent, init to self
		// P = process, auto generated by pre process
		// L = level

		void lcaPreProcess(){
			int i, j;

			//we initialize every element in P with -1
			for (i = 0; i < N; i++){
				for (j = 0; 1 << j < N; j++){
					P[i][j] = -1;
				}
			}

			//the first ancestor of every node i is T[i]
			for (i = 0; i < N; i++){
				P[i][0] = T[i];
			}

			//bottom up dynamic programing
			for (j = 1; 1 << j < N; j++){
				for (i = 0; i < N; i++){
					if (P[i][j - 1] != -1){
						P[i][j] = P[P[i][j - 1]][j - 1];
					}
				}
			}
		}

	public:
		LCA(int n, int *par, int *lv){
			N = n;
			for (int i=0; i<N; i++){
				T[i] = par[i];
				L[i] = lv[i];
			}
			lcaPreProcess();
		}

		int lca(int p, int q){
			int tmp, log, i;

			//if p is situated on a higher level than q then we swap them
			if (L[p] < L[q]){
				tmp = p, p = q, q = tmp;
			}

			//we compute the value of [log(L[p)]
			for (log = 1; 1 << log <= L[p]; log++);
			log--;

			//we find the ancestor of node p situated on the same level
			//with q using the values in P
			for (i = log; i >= 0; i--){
				if (L[p] - (1 << i) >= L[q]){
					p = P[p][i];
				}
			}

			if (p == q) return p;

			//we compute LCA(p, q) using the values in P
			for (i = log; i >= 0; i--){
				if (P[p][i] != -1 && P[p][i] != P[q][i]){
					p = P[p][i], q = P[q][i];
				}
			}

			return T[p];
		}
};

int main(){
	/*
	     0
	   /   \
	  1     2
	 / \   / \
	3   4 5   6
	*/
	int par[] = {0,0,0,1,1,2,2};
	int lv[] = {1,2,2,3,3,3,3};
	LCA lca(7, par, lv);
	cout << lca.lca(0,5) << endl;
	cout << lca.lca(1,6) << endl;
	cout << lca.lca(3,4) << endl;
	cout << lca.lca(3,3) << endl;
	return 0;
}

